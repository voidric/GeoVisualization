// SEGY数据读取解析与处理
async function parseSegyData(buffer) {
    const view = new DataView(buffer);
    const nSamples = view.getInt16(3220, false); 
    const isIBM = view.getInt16(3224, false) === 1;

    const traces = [];
    let offset = 3600; 
    
    // 遍历文件读取地震道
    while (offset < buffer.byteLength) {
        const inline = view.getInt32(offset + 188, false);
        const crossline = view.getInt32(offset + 192, false);
        const data = new Float32Array(nSamples);
        
        let sampleOffset = offset + 240; 
        for(let i=0; i<nSamples; i++) {
            const raw = view.getUint32(sampleOffset, false);
            // IBM浮点转IEEE浮点
            data[i] = isIBM ? ibmToIeee(raw) : view.getFloat32(sampleOffset, false);
            sampleOffset += 4;
        }
        traces.push({ inline, crossline, data });
        offset += 240 + nSamples * 4;
    }
    return traces;
}

// 二维剖面显示 变密度显示
function createDensitySlice(traces, w, h) {
    const rgba = new Uint8Array(w * h * 4);
    // 遍历数据映射颜色
    traces.forEach((t, x) => t.data.forEach((val, y) => {
        // 振幅映射为颜色
        const c = mapToColor(val); 
        const idx = (y * w + x) * 4;
        rgba[idx] = c; rgba[idx+1] = c; rgba[idx+2] = c; rgba[idx+3] = 255;
    }));
    
    // 生成数据纹理
    const tex = new THREE.DataTexture(rgba, w, h, THREE.RGBAFormat);
    tex.needsUpdate = true;
    return new THREE.Mesh(new THREE.PlaneGeometry(w, h), new THREE.MeshBasicMaterial({ map: tex }));
}

// 二维剖面显示 面积显示
function createWiggleSlice(traces) {
    const geometry = new THREE.BufferGeometry();
    const positions = [];
    
    // 构建波形几何线条
    traces.forEach((t, x) => {
        t.data.forEach((amp, y) => {
            // 振幅量叠加到坐标轴
            positions.push(x + amp * gain, y, 0); 
        });
    });
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    return new THREE.LineSegments(geometry, new THREE.LineBasicMaterial({ color: 0x000000 }));
}

// 三维显示
// 三维显示 (Seismic Volume)
function createSeismicVolume(traces, threshold) {
    const vertices = [], colors = [];
    // 随机采样率:25% (消除摩尔纹的关键)
    const samplingRate = 0.25; 

    traces.forEach((t, x) => t.data.forEach((amp, z) => {
        // 随机过滤
        if (Math.random() > samplingRate) return;

        if (Math.abs(amp) > threshold) {
            // 微量随机扰动 (Jitter) 打破网格规律
            const jitter = 0.2;
            const jx = (Math.random() - 0.5) * jitter;
            const jy = (Math.random() - 0.5) * jitter;
            const jz = (Math.random() - 0.5) * jitter;
            
            // 坐标 (含扰动)
            vertices.push(x + jx, t.crossline + jy, z + jz);
            
            // 配色与着色
            const c = amp > 0 ? {r:1,g:0,b:0} : {r:0,g:0,b:1}; 
            colors.push(c.r, c.g, c.b);
        }
    }));
    
    const geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
    geom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    
    // 使用实心渲染 (transparent: false) 虽然丢失透视但彻底解决深度排序伪影
    return new THREE.Points(geom, new THREE.PointsMaterial({ 
        vertexColors: true, 
        size: 2,
        transparent: false,
        opacity: 1.0
    }));
}
